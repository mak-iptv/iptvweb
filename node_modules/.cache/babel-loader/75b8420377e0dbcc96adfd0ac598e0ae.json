{"ast":null,"code":"import _objectSpread from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _wrapRegExp from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapRegExp\";\nimport _regeneratorRuntime from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as axios from \"./axios\";\nimport { getInfo } from \"./user_info\";\nimport { getVodTmdbData, getSeriesTmdbData, clearEpisodeName } from \"./tmdb\";\nimport { downloadEpgDataFromCategories } from \"./epg-database\";\nimport { groupBy } from './group-by';\nimport Axios from \"axios\";\nexport function loadGroup(_x) {\n  return _loadGroup.apply(this, arguments);\n}\n\nfunction _loadGroup() {\n  _loadGroup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(mode) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return axios.post(\"player_api.php\", {\n              username: getInfo().username,\n              password: getInfo().password,\n              action: getAddress(mode, true)\n            }).then(function (res) {\n              return res.data;\n            }).catch(function (err) {\n              return [];\n            });\n\n          case 2:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadGroup.apply(this, arguments);\n}\n\nexport function loadPlaylist(_x2, _x3) {\n  return _loadPlaylist.apply(this, arguments);\n}\n\nfunction _loadPlaylist() {\n  _loadPlaylist = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(mode, group) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return axios.post(\"player_api.php\", {\n              username: getInfo().username,\n              password: getInfo().password,\n              action: getAddress(mode, false),\n              category_id: isNaN(group) ? \"*\" : group\n            }).then(function (res) {\n              return res.data;\n            }).catch(function (err) {\n              return [];\n            });\n\n          case 2:\n            result = _context2.sent;\n\n            if (!(mode === \"live\" && !isNaN(group) && axios.getIsIptveditor() === true)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 6;\n            return downloadEpgDataFromCategories(result);\n\n          case 6:\n            return _context2.abrupt(\"return\", result);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadPlaylist.apply(this, arguments);\n}\n\nexport function loadEpg(_x4) {\n  return _loadEpg.apply(this, arguments);\n}\n\nfunction _loadEpg() {\n  _loadEpg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(epg_id) {\n    var limit,\n        now,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            limit = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 1;\n            now = new Date();\n\n            if (!(axios.getIsIptveditor() === true)) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", []);\n\n          case 4:\n            _context3.next = 6;\n            return axios.post(\"/epg.php\", {\n              username: getInfo().username,\n              password: getInfo().password,\n              action: \"get_simple_data_table\",\n              epg_id: epg_id,\n              limit: limit,\n              start: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 0, 0, 0, 0).getTime() / 1000),\n              stop: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 23, 59, 59, 9999).getTime() / 1000)\n            }, true).catch(function (err) {\n              return [];\n            }).then(function (result) {\n              return result.data;\n            });\n\n          case 6:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadEpg.apply(this, arguments);\n}\n\nexport function loadEpgArray(_x5) {\n  return _loadEpgArray.apply(this, arguments);\n}\n\nfunction _loadEpgArray() {\n  _loadEpgArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(epg_ids) {\n    var limit,\n        now,\n        programmes,\n        set,\n        map,\n        _loop,\n        i,\n        j,\n        toReturn,\n        _args5 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            limit = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 2;\n\n            if (!(axios.getIsIptveditor() === false)) {\n              _context5.next = 3;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", []);\n\n          case 3:\n            now = new Date();\n            programmes = [];\n            set = new Set();\n            map = {};\n            epg_ids.filter(function (x) {\n              return !!x;\n            }).forEach(function (x) {\n              var id = x.replace(/\\.(plus|minus)\\d+$/, \"\");\n              set.add(id);\n              var shift = x.match( /*#__PURE__*/_wrapRegExp(/\\.(plus|minus)([0-9]+)$/, {\n                number: 2\n              }));\n\n              if (shift && shift.groups) {\n                var list = map[id] || [];\n                list.push(shift.groups.number);\n                map[id] = list;\n              }\n            });\n            epg_ids = Array.from(set);\n            _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(i, j) {\n              var sliced, result;\n              return _regeneratorRuntime.wrap(function _loop$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      sliced = epg_ids.slice(i, i + 50);\n                      _context4.next = 3;\n                      return Axios.post(\"\".concat(process.env.REACT_APP_IPTVEDITOR_API, \"webplayer\"), {\n                        username: getInfo().username,\n                        password: getInfo().password,\n                        action: \"get_simple_data_table_array\",\n                        epg_ids: sliced,\n                        limit: limit,\n                        start: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 0, 0, 0, 0).getTime() / 1000),\n                        stop: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 23, 59, 59, 9999).getTime() / 1000)\n                      }).then(function (result) {\n                        return result.data;\n                      }).catch(function (err) {\n                        return [];\n                      });\n\n                    case 3:\n                      result = _context4.sent;\n                      Object.keys(map).filter(function (c) {\n                        return sliced.includes(c);\n                      }).forEach(function (c) {\n                        var pgs = result.filter(function (x) {\n                          return x.id === c;\n                        });\n                        map[c].forEach(function (shift) {\n                          var id = c + (shift > 0 ? \".plus\".concat(shift) : \".minus\".concat(shift));\n                          pgs.forEach(function (p) {\n                            return result.push(_objectSpread(_objectSpread({}, p), {}, {\n                              id: id,\n                              start: p.start + shift * 3600,\n                              stop: p.stop + shift * 3600\n                            }));\n                          });\n                        });\n                      });\n                      result.forEach(function (p) {\n                        return programmes.push(p);\n                      });\n\n                    case 6:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _loop);\n            });\n            i = 0, j = epg_ids.length;\n\n          case 11:\n            if (!(i < j)) {\n              _context5.next = 16;\n              break;\n            }\n\n            return _context5.delegateYield(_loop(i, j), \"t0\", 13);\n\n          case 13:\n            i += 50;\n            _context5.next = 11;\n            break;\n\n          case 16:\n            toReturn = groupBy(programmes, \"id\");\n            return _context5.abrupt(\"return\", toReturn);\n\n          case 18:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _loadEpgArray.apply(this, arguments);\n}\n\nexport function getVodInfo(_x6, _x7, _x8) {\n  return _getVodInfo.apply(this, arguments);\n}\n\nfunction _getVodInfo() {\n  _getVodInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(vod_id, name, existingTmdb) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            result = null;\n\n            if (!(axios.getIsIptveditor() === false)) {\n              _context6.next = 5;\n              break;\n            }\n\n            _context6.next = 4;\n            return axios.post(\"player_api.php\", {\n              username: getInfo().username,\n              password: getInfo().password,\n              action: \"get_vod_info\",\n              vod_id: vod_id\n            }).catch(function (err) {\n              return null;\n            }).then(function (result) {\n              return result.data;\n            });\n\n          case 4:\n            result = _context6.sent;\n\n          case 5:\n            if (!(result && result.info && result.info.cover_big)) {\n              _context6.next = 7;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", result);\n\n          case 7:\n            _context6.next = 9;\n            return getVodTmdbData(name, existingTmdb);\n\n          case 9:\n            return _context6.abrupt(\"return\", _context6.sent);\n\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getVodInfo.apply(this, arguments);\n}\n\nexport function getSeriesInfo(_x9, _x10, _x11, _x12) {\n  return _getSeriesInfo.apply(this, arguments);\n}\n\nfunction _getSeriesInfo() {\n  _getSeriesInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(series_id, name, only_info, existingTmdb) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            result = null;\n\n            if (!(axios.getIsIptveditor() === false || only_info === false)) {\n              _context7.next = 5;\n              break;\n            }\n\n            _context7.next = 4;\n            return axios.post(\"player_api.php\", {\n              username: getInfo().username,\n              password: getInfo().password,\n              action: \"get_series_info\",\n              series_id: series_id\n            }).catch(function (err) {\n              return null;\n            }).then(function (result) {\n              if (result.data && Array.isArray(result.data)) {\n                result.data.forEach(function (x) {\n                  if (!x.episode_num && x.episode) x.episode_num = x.episode;\n                });\n              }\n\n              return result.data;\n            });\n\n          case 4:\n            result = _context7.sent;\n\n          case 5:\n            if (!(axios.getIsIptveditor() === true)) {\n              _context7.next = 11;\n              break;\n            }\n\n            _context7.next = 8;\n            return getSeriesTmdbData(name, result, existingTmdb);\n\n          case 8:\n            return _context7.abrupt(\"return\", _context7.sent);\n\n          case 11:\n            if (only_info === false) clearEpisodeName(name, result);\n\n          case 12:\n            return _context7.abrupt(\"return\", result);\n\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _getSeriesInfo.apply(this, arguments);\n}\n\nvar getAddress = function getAddress(mode, group) {\n  switch (mode) {\n    case \"live\":\n      if (!group) return \"get_live_streams\";else return \"get_live_categories\";\n\n    case \"movie\":\n      if (!group) return \"get_vod_streams\";else return \"get_vod_categories\";\n\n    case \"series\":\n      if (!group) return \"get_series\";else return \"get_series_categories\";\n\n    default:\n      return \"\";\n  }\n};","map":{"version":3,"sources":["C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/src/other/load-playlist.js"],"names":["axios","getInfo","getVodTmdbData","getSeriesTmdbData","clearEpisodeName","downloadEpgDataFromCategories","groupBy","Axios","loadGroup","mode","post","username","password","action","getAddress","then","res","data","catch","err","loadPlaylist","group","category_id","isNaN","result","getIsIptveditor","loadEpg","epg_id","limit","now","Date","start","parseInt","getFullYear","getMonth","getDate","getTime","stop","loadEpgArray","epg_ids","programmes","set","Set","map","filter","x","forEach","id","replace","add","shift","match","groups","list","push","number","Array","from","i","j","sliced","slice","process","env","REACT_APP_IPTVEDITOR_API","Object","keys","c","includes","pgs","p","length","toReturn","getVodInfo","vod_id","name","existingTmdb","info","cover_big","getSeriesInfo","series_id","only_info","isArray","episode_num","episode"],"mappings":"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","sourcesContent":["import * as axios from \"./axios\";\nimport { getInfo } from \"./user_info\"\nimport { getVodTmdbData, getSeriesTmdbData, clearEpisodeName } from \"./tmdb\"\nimport { downloadEpgDataFromCategories } from \"./epg-database\";\nimport { groupBy } from './group-by';\nimport Axios from \"axios\";\n\nexport async function loadGroup(mode) {\n    return await axios.post(\"player_api.php\", {\n        username: getInfo().username,\n        password: getInfo().password,\n        action: getAddress(mode, true)\n    }).then(res => res.data).catch(err => [])\n}\n\nexport async function loadPlaylist(mode, group) {\n    const result = await axios.post(\"player_api.php\", {\n        username: getInfo().username,\n        password: getInfo().password,\n        action: getAddress(mode, false),\n        category_id: isNaN(group) ? \"*\" : group\n    }).then(res => res.data).catch(err => [])\n    if (mode === \"live\" && !isNaN(group) && axios.getIsIptveditor() === true) {\n        await downloadEpgDataFromCategories(result)\n    }\n    //else if(mode===\"movie\")\n    //    result.data = result.data.sort((a,b)=>b.added-a.added)\n    //else if(mode===\"series\")\n    //    result.data = result.data.sort((a,b)=>b.last_modified-a.last_modified)\n    return result;\n}\n\nexport async function loadEpg(epg_id, limit = 1) {\n    let now = new Date();\n\n    if (axios.getIsIptveditor() === true) return [];\n\n    return await axios.post(\"/epg.php\", {\n        username: getInfo().username,\n        password: getInfo().password,\n        action: \"get_simple_data_table\",\n        epg_id: epg_id,\n        limit: limit,\n        start: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 0, 0, 0, 0).getTime() / 1000),\n        stop: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 23, 59, 59, 9999).getTime() / 1000),\n    }, true).catch(err => [])\n        .then(result => {\n            return result.data;\n        });\n}\n\n\nexport async function loadEpgArray(epg_ids, limit = 2) {\n    if (axios.getIsIptveditor() === false) return []\n    let now = new Date();\n    const programmes = [];\n\n    const set = new Set()\n    const map = {}\n\n    epg_ids.filter(x=>!!x).forEach(x=> {\n        const id = x.replace(/\\.(plus|minus)\\d+$/,\"\")\n        set.add(id)\n\n        const shift = x.match(/\\.(plus|minus)(?<number>\\d+)$/)\n        if(shift && shift.groups){\n            const list = map[id] || []\n            list.push(shift.groups.number)\n            map[id] = list\n        }\n    })\n    epg_ids = Array.from(set)\n\n    for (let i = 0, j = epg_ids.length; i < j; i += 50) {\n        let sliced = epg_ids.slice(i, i + 50)\n\n        const result = await Axios.post( `${process.env.REACT_APP_IPTVEDITOR_API}webplayer`, {\n                username: getInfo().username,\n            password: getInfo().password,\n            action: \"get_simple_data_table_array\",\n            epg_ids: sliced,\n            limit: limit,\n            start: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 0, 0, 0, 0).getTime() / 1000),\n            stop: parseInt(new Date(now.getFullYear(), now.getMonth(), now.getDate() + limit - 1, 23, 59, 59, 9999).getTime() / 1000),\n        }).then(result=> result.data).catch(err=> [])\n        \n        Object.keys(map).filter(c=> sliced.includes(c)).forEach(c=>{\n            const pgs = result.filter(x=>x.id === c)\n            map[c].forEach(shift => {\n                const id = c + (shift > 0 ? `.plus${shift}` : `.minus${shift}`)\n                pgs.forEach(p=> result.push({\n                    ...p,\n                    id,\n                    start: p.start + (shift * 3600),\n                    stop: p.stop + (shift * 3600)\n                }))\n            })\n            \n        })\n\n        result.forEach(p=> programmes.push(p))\n    }\n\n    const toReturn = groupBy(programmes, \"id\")\n\n    return toReturn;\n}\n\nexport async function getVodInfo(vod_id, name, existingTmdb) {\n    let result = null;\n    if (axios.getIsIptveditor() === false) {\n        result = await axios.post(\"player_api.php\", {\n            username: getInfo().username,\n            password: getInfo().password,\n            action: \"get_vod_info\",\n            vod_id: vod_id,\n        }).catch(err => null)\n            .then(result => {\n                return result.data;\n            });\n    }\n\n    if (result && result.info && result.info.cover_big)\n        return result;\n\n    return await getVodTmdbData(name, existingTmdb)\n}\n\nexport async function getSeriesInfo(series_id, name, only_info, existingTmdb) {\n    let result = null;\n    if (axios.getIsIptveditor() === false || only_info === false) {\n        result = await axios.post(\"player_api.php\", {\n            username: getInfo().username,\n            password: getInfo().password,\n            action: \"get_series_info\",\n            series_id: series_id,\n        }).catch(err => null)\n            .then(result => {\n                if (result.data && Array.isArray(result.data)) {\n                    result.data.forEach(x => {\n                        if (!x.episode_num && x.episode)\n                            x.episode_num = x.episode\n                    })\n                }\n                return result.data;\n            });\n    }\n\n    if (axios.getIsIptveditor() === true)\n        return await getSeriesTmdbData(name, result, existingTmdb)\n    else if (only_info === false)\n        clearEpisodeName(name, result)\n    return result;\n}\n\n\nconst getAddress = (mode, group) => {\n    switch (mode) {\n        case \"live\":\n            if (!group)\n                return \"get_live_streams\"\n            else return \"get_live_categories\"\n        case \"movie\":\n            if (!group)\n                return \"get_vod_streams\"\n            else return \"get_vod_categories\"\n        case \"series\":\n            if (!group)\n                return \"get_series\"\n            else return \"get_series_categories\"\n        default:\n            return \"\";\n    }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}