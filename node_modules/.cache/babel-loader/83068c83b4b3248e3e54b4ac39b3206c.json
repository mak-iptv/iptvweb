{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { loadEpg, loadEpgArray } from \"./load-playlist\";\nimport { getIsIptveditor } from \"./axios\";\nvar epgMap = new Map();\n/*\nepgMap (map -> key id string)\n------id (string -> object)\n------------day1  (object -> array)\n------------------title\n------------------description\n------------------start\n------------------end\n\n------------day2\n------------------title\n------------------description\n------------------start\n------------------end\n\n------------day3\n------------------title\n------------------description\n------------------start\n------------------end\n*/\n\nexport function downloadEpgData(_x, _x2) {\n  return _downloadEpgData.apply(this, arguments);\n}\n\nfunction _downloadEpgData() {\n  _downloadEpgData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(chId, epgId) {\n    var limit,\n        shift,\n        available,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            limit = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;\n            shift = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;\n\n            if (!(epgId === \"NULL\" || !epgId)) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\", []);\n\n          case 4:\n            available = isAvailable(epgId, limit);\n\n            if (!(available === -1 || !epgId)) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", []);\n\n          case 9:\n            if (!(available === 1)) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.abrupt(\"return\", getEpg(epgId, limit, shift));\n\n          case 13:\n            _context.next = 15;\n            return loadEpg(epgId, limit).then(function (result) {\n              if (!result) return null;\n              result = result.epg_listings;\n\n              if (result && result.length > 0) {\n                result = convertEpgListing(result);\n                var dataset = epgMap.has(epgId) ? epgMap.get(epgId) : {\n                  days: {},\n                  data: []\n                };\n                mergeDay(dataset, result, limit);\n                epgMap.set(epgId, dataset);\n              } else {\n                if (epgMap.has(epgId)) {\n                  if (!epgMap.get(epgId)) return [];\n                  if (!epgMap.get(epgId).days) epgMap.get(epgId).days = {};\n                  epgMap.get(epgId).days[limit] = false;\n                } else if (limit === 1) epgMap.set(epgId, false);else {\n                  var obj = {\n                    days: {},\n                    data: []\n                  };\n                  obj.days[limit] = false;\n                  epgMap.set(epgId, obj);\n                }\n\n                return [];\n              }\n            });\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _downloadEpgData.apply(this, arguments);\n}\n\nexport function isAvailable(id) {\n  var day = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  if (epgMap.has(id)) {\n    if (!epgMap.get(id).days || !epgMap.get(id).days[day]) return 0;else if (epgMap.get(id).days[day] === false) return -1;else if (epgMap.get(id).days[day] === true) return 1;\n  }\n\n  return 0;\n}\n/*\nepgs_multiple:[\n    {id: \"ciao.it\", data:[{title:\"....\"}]}\n]\n*/\n\nexport function downloadEpgDataFromCategories(_x3) {\n  return _downloadEpgDataFromCategories.apply(this, arguments);\n}\n\nfunction _downloadEpgDataFromCategories() {\n  _downloadEpgDataFromCategories = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(channels) {\n    var limit, epgIds, toDownload, result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            limit = 1;\n            epgIds = Array.from(new Set(channels.map(function (x) {\n              return x.epg_channel_id;\n            }))).filter(function (x) {\n              return x && x !== \"NULL\";\n            });\n            toDownload = isAvailableArray(epgIds);\n\n            if (!(toDownload.length === 0)) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 7:\n            _context2.next = 9;\n            return loadEpgArray(toDownload, limit);\n\n          case 9:\n            result = _context2.sent;\n            toDownload.forEach(function (id) {\n              var data = result[[id]];\n\n              if (data && data.length > 0) {\n                data = convertEpgListing(data);\n                var dataset = epgMap.has(id) ? epgMap.get(id) : {\n                  days: {},\n                  data: []\n                };\n                mergeDay(dataset, data, limit);\n                epgMap.set(id, dataset);\n              } else {\n                if (epgMap.has(id)) {\n                  if (!epgMap.get(id)) {}\n\n                  if (!epgMap.get(id).days) epgMap.get(id).days = {};\n                  epgMap.get(id).days[limit] = false;\n                } else if (limit === 1) epgMap.set(id, false);else {\n                  var obj = {\n                    days: {},\n                    data: []\n                  };\n                  obj.days[limit] = false;\n                  epgMap.set(id, obj);\n                }\n              }\n            });\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _downloadEpgDataFromCategories.apply(this, arguments);\n}\n\nexport function isAvailableArray(ids) {\n  var toReturn = [];\n  ids.forEach(function (id) {\n    if (!epgMap.has(id)) {\n      toReturn.push(id);\n    }\n  });\n  return toReturn;\n}\nexport function getEpg(id) {\n  var day = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!id || isAvailable(id, day) !== 1) return [];\n  var arr = epgMap.get(id).data.map(function (x) {\n    return _objectSpread({}, x);\n  });\n  ;\n  var start = new Date();\n  start.setHours(0, 0, 0, 0);\n  start = start.getTime() + (day - 1) * 3600000 * 24;\n  var end = new Date();\n  end.setHours(23, 59, 59, 999);\n  end = end.getTime() + (day - 1) * 3600000 * 24;\n\n  if (shift !== 0) {\n    arr.forEach(function (x) {\n      var sh = shift * 60 * 60 * 1000;\n      x.start += sh;\n      x.end += sh;\n    });\n  }\n\n  return arr.filter(function (x) {\n    return x.start >= start && x.start < end || x.start < start && x.end > start;\n  });\n}\nexport function getSingleEpgNow(id, shift) {\n  var arr = getEpg(id, 1, shift);\n  return arr.find(function (x) {\n    return x.start <= Date.now() && x.end > Date.now();\n  });\n}\nexport function getEpgNow(id, shift) {\n  var arr = getEpg(id, 1, shift);\n  var end = new Date();\n  end.setHours(23, 59, 59, 999);\n  return arr.filter(function (x) {\n    return x.start <= Date.now() && x.end > Date.now() || x.start > Date.now() && x.start < end.getTime();\n  });\n}\n\nfunction convertEpgListing(data) {\n  return data.map(function (x) {\n    return {\n      title: x.title,\n      description: x.description,\n      start: convertTimestamp(x.start || x.start_timestamp),\n      end: convertTimestamp(x.stop || x.stop_timestamp)\n    };\n  });\n}\n\nfunction convertTimestamp(time) {\n  return parseInt(time + \"000\");\n}\n\nfunction mergeDay(dataset, entries, day) {\n  dataset.days[day] = true;\n  dataset.data = dataset.data.concat(entries);\n  dataset.data = dataset.data.sort(function (a, b) {\n    return a.start - b.start;\n  }).filter(function (x, index, self) {\n    return index === self.findIndex(function (t) {\n      return t.start === x.start;\n    });\n  });\n  return dataset;\n}","map":{"version":3,"sources":["C:/Users/rayuv/OneDrive/Documents/GitHub/Reactv/src/other/epg-database.js"],"names":["loadEpg","loadEpgArray","getIsIptveditor","epgMap","Map","downloadEpgData","chId","epgId","limit","shift","available","isAvailable","getEpg","then","result","epg_listings","length","convertEpgListing","dataset","has","get","days","data","mergeDay","set","obj","id","day","downloadEpgDataFromCategories","channels","epgIds","Array","from","Set","map","x","epg_channel_id","filter","toDownload","isAvailableArray","forEach","ids","toReturn","push","arr","start","Date","setHours","getTime","end","sh","getSingleEpgNow","find","now","getEpgNow","title","description","convertTimestamp","start_timestamp","stop","stop_timestamp","time","parseInt","entries","concat","sort","a","b","index","self","findIndex","t"],"mappings":";;;AAAA,SAASA,OAAT,EAAkBC,YAAlB,QAAsC,iBAAtC;AACA,SAASC,eAAT,QAAgC,SAAhC;AAEA,IAAMC,MAAM,GAAG,IAAIC,GAAJ,EAAf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,gBAAsBC,eAAtB;AAAA;AAAA;;;8EAAO,iBAA+BC,IAA/B,EAAqCC,KAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4CC,YAAAA,KAA5C,2DAAoD,CAApD;AAAuDC,YAAAA,KAAvD,2DAA+D,CAA/D;;AAAA,kBACAF,KAAK,KAAK,MAAV,IAAoB,CAACA,KADrB;AAAA;AAAA;AAAA;;AAAA,6CAEQ,EAFR;;AAAA;AAGCG,YAAAA,SAHD,GAGaC,WAAW,CAACJ,KAAD,EAAQC,KAAR,CAHxB;;AAAA,kBAKCE,SAAS,KAAK,CAAC,CAAf,IAAoB,CAACH,KALtB;AAAA;AAAA;AAAA;;AAAA,6CAMQ,EANR;;AAAA;AAAA,kBAOMG,SAAS,KAAK,CAPpB;AAAA;AAAA;AAAA;;AAAA,6CAQQE,MAAM,CAACL,KAAD,EAAQC,KAAR,EAAeC,KAAf,CARd;;AAAA;AAAA;AAAA,mBAUOT,OAAO,CAACO,KAAD,EAAQC,KAAR,CAAP,CAAsBK,IAAtB,CAA2B,UAAAC,MAAM,EAAI;AACvC,kBAAI,CAACA,MAAL,EACI,OAAO,IAAP;AACJA,cAAAA,MAAM,GAAGA,MAAM,CAACC,YAAhB;;AACA,kBAAID,MAAM,IAAIA,MAAM,CAACE,MAAP,GAAgB,CAA9B,EAAiC;AAC7BF,gBAAAA,MAAM,GAAGG,iBAAiB,CAACH,MAAD,CAA1B;AAEA,oBAAMI,OAAO,GAAGf,MAAM,CAACgB,GAAP,CAAWZ,KAAX,IAAoBJ,MAAM,CAACiB,GAAP,CAAWb,KAAX,CAApB,GAAwC;AAAEc,kBAAAA,IAAI,EAAE,EAAR;AAAYC,kBAAAA,IAAI,EAAE;AAAlB,iBAAxD;AACAC,gBAAAA,QAAQ,CAACL,OAAD,EAAUJ,MAAV,EAAkBN,KAAlB,CAAR;AACAL,gBAAAA,MAAM,CAACqB,GAAP,CAAWjB,KAAX,EAAkBW,OAAlB;AAEH,eAPD,MAOO;AACH,oBAAIf,MAAM,CAACgB,GAAP,CAAWZ,KAAX,CAAJ,EAAuB;AACnB,sBAAI,CAACJ,MAAM,CAACiB,GAAP,CAAWb,KAAX,CAAL,EACI,OAAO,EAAP;AACJ,sBAAI,CAACJ,MAAM,CAACiB,GAAP,CAAWb,KAAX,EAAkBc,IAAvB,EACIlB,MAAM,CAACiB,GAAP,CAAWb,KAAX,EAAkBc,IAAlB,GAAyB,EAAzB;AACJlB,kBAAAA,MAAM,CAACiB,GAAP,CAAWb,KAAX,EAAkBc,IAAlB,CAAuBb,KAAvB,IAAgC,KAAhC;AACH,iBAND,MAMO,IAAIA,KAAK,KAAK,CAAd,EACHL,MAAM,CAACqB,GAAP,CAAWjB,KAAX,EAAkB,KAAlB,EADG,KAEF;AACD,sBAAIkB,GAAG,GAAG;AAAEJ,oBAAAA,IAAI,EAAE,EAAR;AAAYC,oBAAAA,IAAI,EAAE;AAAlB,mBAAV;AACAG,kBAAAA,GAAG,CAACJ,IAAJ,CAASb,KAAT,IAAkB,KAAlB;AACAL,kBAAAA,MAAM,CAACqB,GAAP,CAAWjB,KAAX,EAAkBkB,GAAlB;AACH;;AACD,uBAAO,EAAP;AACH;AACJ,aA3BK,CAVP;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAyCP,OAAO,SAASd,WAAT,CAAqBe,EAArB,EAAkC;AAAA,MAATC,GAAS,uEAAH,CAAG;;AACrC,MAAIxB,MAAM,CAACgB,GAAP,CAAWO,EAAX,CAAJ,EAAoB;AAChB,QAAI,CAACvB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAhB,IAAwB,CAAClB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAf,CAAoBM,GAApB,CAA7B,EACI,OAAO,CAAP,CADJ,KAEK,IAAIxB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAf,CAAoBM,GAApB,MAA6B,KAAjC,EACD,OAAO,CAAC,CAAR,CADC,KAEA,IAAIxB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAf,CAAoBM,GAApB,MAA6B,IAAjC,EACD,OAAO,CAAP;AACP;;AACD,SAAO,CAAP;AACH;AAGD;AACA;AACA;AACA;AACA;;AAEA,gBAAsBC,6BAAtB;AAAA;AAAA;;;4FAAO,kBAA6CC,QAA7C;AAAA;AAAA;AAAA;AAAA;AAAA;AACGrB,YAAAA,KADH,GACW,CADX;AAECsB,YAAAA,MAFD,GAEUC,KAAK,CAACC,IAAN,CAAW,IAAIC,GAAJ,CAAQJ,QAAQ,CAACK,GAAT,CAAa,UAAAC,CAAC;AAAA,qBAAIA,CAAC,CAACC,cAAN;AAAA,aAAd,CAAR,CAAX,EAAyDC,MAAzD,CAAgE,UAAAF,CAAC;AAAA,qBAAEA,CAAC,IAAIA,CAAC,KAAK,MAAb;AAAA,aAAjE,CAFV;AAGCG,YAAAA,UAHD,GAGcC,gBAAgB,CAACT,MAAD,CAH9B;;AAAA,kBAKCQ,UAAU,CAACtB,MAAX,KAAsB,CALvB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,mBAQsBf,YAAY,CAACqC,UAAD,EAAa9B,KAAb,CARlC;;AAAA;AAQOM,YAAAA,MARP;AASCwB,YAAAA,UAAU,CAACE,OAAX,CAAmB,UAAAd,EAAE,EAAI;AACrB,kBAAIJ,IAAI,GAAGR,MAAM,CAAC,CAACY,EAAD,CAAD,CAAjB;;AACA,kBAAIJ,IAAI,IAAIA,IAAI,CAACN,MAAL,GAAc,CAA1B,EAA6B;AACzBM,gBAAAA,IAAI,GAAGL,iBAAiB,CAACK,IAAD,CAAxB;AACA,oBAAMJ,OAAO,GAAGf,MAAM,CAACgB,GAAP,CAAWO,EAAX,IAAiBvB,MAAM,CAACiB,GAAP,CAAWM,EAAX,CAAjB,GAAkC;AAAEL,kBAAAA,IAAI,EAAE,EAAR;AAAYC,kBAAAA,IAAI,EAAE;AAAlB,iBAAlD;AACAC,gBAAAA,QAAQ,CAACL,OAAD,EAAUI,IAAV,EAAgBd,KAAhB,CAAR;AACAL,gBAAAA,MAAM,CAACqB,GAAP,CAAWE,EAAX,EAAeR,OAAf;AACH,eALD,MAKO;AACH,oBAAIf,MAAM,CAACgB,GAAP,CAAWO,EAAX,CAAJ,EAAoB;AAChB,sBAAI,CAACvB,MAAM,CAACiB,GAAP,CAAWM,EAAX,CAAL,EAAoB,CAEnB;;AACD,sBAAI,CAACvB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAApB,EACIlB,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAf,GAAsB,EAAtB;AACJlB,kBAAAA,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeL,IAAf,CAAoBb,KAApB,IAA6B,KAA7B;AACH,iBAPD,MAOO,IAAIA,KAAK,KAAK,CAAd,EACHL,MAAM,CAACqB,GAAP,CAAWE,EAAX,EAAe,KAAf,EADG,KAEF;AACD,sBAAID,GAAG,GAAG;AAAEJ,oBAAAA,IAAI,EAAE,EAAR;AAAYC,oBAAAA,IAAI,EAAE;AAAlB,mBAAV;AACAG,kBAAAA,GAAG,CAACJ,IAAJ,CAASb,KAAT,IAAkB,KAAlB;AACAL,kBAAAA,MAAM,CAACqB,GAAP,CAAWE,EAAX,EAAeD,GAAf;AACH;AACJ;AACJ,aAvBD;;AATD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAsCP,OAAO,SAASc,gBAAT,CAA0BE,GAA1B,EAA+B;AAClC,MAAMC,QAAQ,GAAG,EAAjB;AACAD,EAAAA,GAAG,CAACD,OAAJ,CAAY,UAAAd,EAAE,EAAI;AACd,QAAI,CAACvB,MAAM,CAACgB,GAAP,CAAWO,EAAX,CAAL,EAAqB;AACjBgB,MAAAA,QAAQ,CAACC,IAAT,CAAcjB,EAAd;AACH;AACJ,GAJD;AAKA,SAAOgB,QAAP;AACH;AAID,OAAO,SAAS9B,MAAT,CAAgBc,EAAhB,EAAwC;AAAA,MAApBC,GAAoB,uEAAd,CAAc;AAAA,MAAXlB,KAAW,uEAAH,CAAG;AAC3C,MAAI,CAACiB,EAAD,IAAOf,WAAW,CAACe,EAAD,EAAKC,GAAL,CAAX,KAAyB,CAApC,EACI,OAAO,EAAP;AACJ,MAAIiB,GAAG,GAAGzC,MAAM,CAACiB,GAAP,CAAWM,EAAX,EAAeJ,IAAf,CAAoBY,GAApB,CAAwB,UAACC,CAAD;AAAA,6BAAaA,CAAb;AAAA,GAAxB,CAAV;AAAqD;AAErD,MAAIU,KAAK,GAAG,IAAIC,IAAJ,EAAZ;AACAD,EAAAA,KAAK,CAACE,QAAN,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB;AACAF,EAAAA,KAAK,GAAGA,KAAK,CAACG,OAAN,KAAmB,CAACrB,GAAG,GAAG,CAAP,IAAY,OAAZ,GAAsB,EAAjD;AAEA,MAAIsB,GAAG,GAAG,IAAIH,IAAJ,EAAV;AACAG,EAAAA,GAAG,CAACF,QAAJ,CAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,GAAzB;AACAE,EAAAA,GAAG,GAAGA,GAAG,CAACD,OAAJ,KAAiB,CAACrB,GAAG,GAAG,CAAP,IAAY,OAAZ,GAAsB,EAA7C;;AAEA,MAAIlB,KAAK,KAAK,CAAd,EAAiB;AACbmC,IAAAA,GAAG,CAACJ,OAAJ,CAAY,UAAAL,CAAC,EAAI;AACb,UAAMe,EAAE,GAAGzC,KAAK,GAAG,EAAR,GAAa,EAAb,GAAkB,IAA7B;AACA0B,MAAAA,CAAC,CAACU,KAAF,IAAWK,EAAX;AACAf,MAAAA,CAAC,CAACc,GAAF,IAASC,EAAT;AACH,KAJD;AAKH;;AAED,SAAON,GAAG,CAACP,MAAJ,CAAW,UAAAF,CAAC;AAAA,WAAKA,CAAC,CAACU,KAAF,IAAWA,KAAX,IAAoBV,CAAC,CAACU,KAAF,GAAUI,GAA/B,IAAwCd,CAAC,CAACU,KAAF,GAAUA,KAAV,IAAmBV,CAAC,CAACc,GAAF,GAAQJ,KAAvE;AAAA,GAAZ,CAAP;AACH;AAED,OAAO,SAASM,eAAT,CAAyBzB,EAAzB,EAA6BjB,KAA7B,EAAoC;AACvC,MAAImC,GAAG,GAAGhC,MAAM,CAACc,EAAD,EAAK,CAAL,EAAQjB,KAAR,CAAhB;AACA,SAAOmC,GAAG,CAACQ,IAAJ,CAAS,UAAAjB,CAAC;AAAA,WAAIA,CAAC,CAACU,KAAF,IAAWC,IAAI,CAACO,GAAL,EAAX,IAAyBlB,CAAC,CAACc,GAAF,GAAQH,IAAI,CAACO,GAAL,EAArC;AAAA,GAAV,CAAP;AACH;AAED,OAAO,SAASC,SAAT,CAAmB5B,EAAnB,EAAuBjB,KAAvB,EAA8B;AACjC,MAAImC,GAAG,GAAGhC,MAAM,CAACc,EAAD,EAAK,CAAL,EAAQjB,KAAR,CAAhB;AACA,MAAIwC,GAAG,GAAG,IAAIH,IAAJ,EAAV;AACAG,EAAAA,GAAG,CAACF,QAAJ,CAAa,EAAb,EAAiB,EAAjB,EAAqB,EAArB,EAAyB,GAAzB;AACA,SAAOH,GAAG,CAACP,MAAJ,CAAW,UAAAF,CAAC;AAAA,WACdA,CAAC,CAACU,KAAF,IAAWC,IAAI,CAACO,GAAL,EAAX,IAAyBlB,CAAC,CAACc,GAAF,GAAQH,IAAI,CAACO,GAAL,EAAlC,IACClB,CAAC,CAACU,KAAF,GAAUC,IAAI,CAACO,GAAL,EAAV,IAAwBlB,CAAC,CAACU,KAAF,GAAUI,GAAG,CAACD,OAAJ,EAFpB;AAAA,GAAZ,CAAP;AAGH;;AAID,SAAS/B,iBAAT,CAA2BK,IAA3B,EAAiC;AAC7B,SAAOA,IAAI,CAACY,GAAL,CAAS,UAAAC,CAAC,EAAI;AACjB,WAAO;AACHoB,MAAAA,KAAK,EAAEpB,CAAC,CAACoB,KADN;AAEHC,MAAAA,WAAW,EAAErB,CAAC,CAACqB,WAFZ;AAGHX,MAAAA,KAAK,EAAEY,gBAAgB,CAACtB,CAAC,CAACU,KAAF,IAAWV,CAAC,CAACuB,eAAd,CAHpB;AAIHT,MAAAA,GAAG,EAAEQ,gBAAgB,CAACtB,CAAC,CAACwB,IAAF,IAAUxB,CAAC,CAACyB,cAAb;AAJlB,KAAP;AAMH,GAPM,CAAP;AAQH;;AAED,SAASH,gBAAT,CAA0BI,IAA1B,EAAgC;AAC5B,SAAOC,QAAQ,CAACD,IAAI,GAAG,KAAR,CAAf;AACH;;AAGD,SAAStC,QAAT,CAAkBL,OAAlB,EAA2B6C,OAA3B,EAAoCpC,GAApC,EAAyC;AACrCT,EAAAA,OAAO,CAACG,IAAR,CAAaM,GAAb,IAAoB,IAApB;AACAT,EAAAA,OAAO,CAACI,IAAR,GAAeJ,OAAO,CAACI,IAAR,CAAa0C,MAAb,CAAoBD,OAApB,CAAf;AACA7C,EAAAA,OAAO,CAACI,IAAR,GAAeJ,OAAO,CAACI,IAAR,CAAa2C,IAAb,CAAkB,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUD,CAAC,CAACrB,KAAF,GAAUsB,CAAC,CAACtB,KAAtB;AAAA,GAAlB,EAA+CR,MAA/C,CAAsD,UAACF,CAAD,EAAIiC,KAAJ,EAAWC,IAAX;AAAA,WACjED,KAAK,KAAKC,IAAI,CAACC,SAAL,CAAe,UAACC,CAAD;AAAA,aACrBA,CAAC,CAAC1B,KAAF,KAAYV,CAAC,CAACU,KADO;AAAA,KAAf,CADuD;AAAA,GAAtD,CAAf;AAKA,SAAO3B,OAAP;AACH","sourcesContent":["import { loadEpg, loadEpgArray } from \"./load-playlist\"\nimport { getIsIptveditor } from \"./axios\"\n\nconst epgMap = new Map();\n/*\nepgMap (map -> key id string)\n------id (string -> object)\n------------day1  (object -> array)\n------------------title\n------------------description\n------------------start\n------------------end\n\n------------day2\n------------------title\n------------------description\n------------------start\n------------------end\n\n------------day3\n------------------title\n------------------description\n------------------start\n------------------end\n*/\n\n\nexport async function downloadEpgData(chId, epgId, limit = 1, shift = 0) {\n    if(epgId === \"NULL\" || !epgId)\n        return []\n    let available = isAvailable(epgId, limit);\n\n    if (available === -1 || !epgId)\n        return [];\n    else if (available === 1)\n        return getEpg(epgId, limit, shift);\n    else {\n        await loadEpg(epgId, limit).then(result => {\n            if (!result)\n                return null;\n            result = result.epg_listings;\n            if (result && result.length > 0) {\n                result = convertEpgListing(result);\n\n                const dataset = epgMap.has(epgId) ? epgMap.get(epgId) : { days: {}, data: [] }\n                mergeDay(dataset, result, limit);\n                epgMap.set(epgId, dataset)\n\n            } else {\n                if (epgMap.has(epgId)) {\n                    if (!epgMap.get(epgId))\n                        return [];\n                    if (!epgMap.get(epgId).days)\n                        epgMap.get(epgId).days = {}\n                    epgMap.get(epgId).days[limit] = false;\n                } else if (limit === 1)\n                    epgMap.set(epgId, false);\n                else {\n                    let obj = { days: {}, data: [] };\n                    obj.days[limit] = false;\n                    epgMap.set(epgId, obj);\n                }\n                return [];\n            }\n        })\n    }\n}\n\nexport function isAvailable(id, day = 1) {\n    if (epgMap.has(id)) {\n        if (!epgMap.get(id).days || !epgMap.get(id).days[day])\n            return 0;\n        else if (epgMap.get(id).days[day] === false)\n            return -1\n        else if (epgMap.get(id).days[day] === true)\n            return 1;\n    }\n    return 0;\n}\n\n\n/*\nepgs_multiple:[\n    {id: \"ciao.it\", data:[{title:\"....\"}]}\n]\n*/\n\nexport async function downloadEpgDataFromCategories(channels) {\n    const limit = 1\n    let epgIds = Array.from(new Set(channels.map(x => x.epg_channel_id))).filter(x=>x && x !== \"NULL\")\n    let toDownload = isAvailableArray(epgIds);\n\n    if (toDownload.length === 0)\n        return;\n    else {\n        const result = await loadEpgArray(toDownload, limit)\n        toDownload.forEach(id => {\n            let data = result[[id]]\n            if (data && data.length > 0) {\n                data = convertEpgListing(data);\n                const dataset = epgMap.has(id) ? epgMap.get(id) : { days: {}, data: [] }\n                mergeDay(dataset, data, limit);\n                epgMap.set(id, dataset)\n            } else {\n                if (epgMap.has(id)) {\n                    if (!epgMap.get(id)){\n\n                    }\n                    if (!epgMap.get(id).days)\n                        epgMap.get(id).days = {}\n                    epgMap.get(id).days[limit] = false;\n                } else if (limit === 1)\n                    epgMap.set(id, false);\n                else {\n                    let obj = { days: {}, data: [] };\n                    obj.days[limit] = false;\n                    epgMap.set(id, obj);\n                }\n            }\n        })\n\n    }\n}\n\n\nexport function isAvailableArray(ids) {\n    const toReturn = []\n    ids.forEach(id => {\n        if (!epgMap.has(id)) {\n            toReturn.push(id)\n        }\n    })\n    return toReturn\n}\n\n\n\nexport function getEpg(id, day = 1, shift = 0) {\n    if (!id || isAvailable(id, day) !== 1)\n        return [];\n    let arr = epgMap.get(id).data.map((x) => ({ ...x }));;\n\n    let start = new Date();\n    start.setHours(0, 0, 0, 0);\n    start = start.getTime() + ((day - 1) * 3600000 * 24)\n\n    let end = new Date();\n    end.setHours(23, 59, 59, 999);\n    end = end.getTime() + ((day - 1) * 3600000 * 24)\n\n    if (shift !== 0) {\n        arr.forEach(x => {\n            const sh = shift * 60 * 60 * 1000;\n            x.start += sh;\n            x.end += sh\n        })\n    }\n\n    return arr.filter(x => (x.start >= start && x.start < end) || (x.start < start && x.end > start));\n}\n\nexport function getSingleEpgNow(id, shift) {\n    let arr = getEpg(id, 1, shift);\n    return arr.find(x => x.start <= Date.now() && x.end > Date.now())\n}\n\nexport function getEpgNow(id, shift) {\n    let arr = getEpg(id, 1, shift);\n    let end = new Date();\n    end.setHours(23, 59, 59, 999);\n    return arr.filter(x =>\n        (x.start <= Date.now() && x.end > Date.now()) ||\n        (x.start > Date.now() && x.start < end.getTime()))\n}\n\n\n\nfunction convertEpgListing(data) {\n    return data.map(x => {\n        return {\n            title: x.title,\n            description: x.description,\n            start: convertTimestamp(x.start || x.start_timestamp),\n            end: convertTimestamp(x.stop || x.stop_timestamp)\n        }\n    })\n}\n\nfunction convertTimestamp(time) {\n    return parseInt(time + \"000\");\n}\n\n\nfunction mergeDay(dataset, entries, day) {\n    dataset.days[day] = true\n    dataset.data = dataset.data.concat(entries);\n    dataset.data = dataset.data.sort((a, b) => a.start - b.start).filter((x, index, self) =>\n        index === self.findIndex((t) => (\n            t.start === x.start\n        ))\n    )\n    return dataset;\n}"]},"metadata":{},"sourceType":"module"}